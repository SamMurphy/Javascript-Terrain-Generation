
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Terrain Generation Techniques - Sam Murphy</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info">Terrain Generation Techniques - Sam Murphy<br />Left click to orbit, right click to pan, scroll to zoom.</div>

		<script src="js/three.js"></script>

		<script src="js/OrbitControls.js"></script>

		<script src="js/ImprovedNoise.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/dat.gui.min.js"></script>

		<script>

			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;

			var camera, controls, scene, renderer;

			var mesh, texture, bottomMesh;

			var detail = 8;
			var worldSize = Math.pow(2, detail) + 1;

			var clock = new THREE.Clock();

			var roughness;

			var perlin = true;
			var diamondSquare = false;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );
				camera.position.set(5500, 10000, 5500);

				scene = new THREE.Scene();

				controls =  new THREE.OrbitControls( camera );
				controls.target.set(0, 0, 0);
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.keys = [ 65, 83, 68 ];

				roughness = 10;

				generate();

				var bottom_geometry = new THREE.PlaneGeometry(7500, 7500);
				bottom_geometry.computeFaceNormals();
                bottom_geometry.computeVertexNormals();
				bottom_material = new THREE.MeshNormalMaterial();
				bottomMesh = new THREE.Mesh(bottom_geometry, bottom_material);
				bottomMesh.rotation.x = -Math.PI / 2.0;
				bottomMesh.rotation.y = -Math.PI;
				scene.add( bottomMesh );

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				//stats = new Stats();
				//container.appendChild( stats.dom );

				var gui = new dat.GUI();

				var button = { 
					Generate:function(){ scene.remove(mesh); generate(); },
					GeneratePerlin:function(){ perlin = true; diamondSquare = false; scene.remove(mesh); generate(); },
					GenerateDiamondSquare:function(){ perlin = false; diamondSquare = true; scene.remove(mesh); generate(); }
				};

				gui.add(this, 'detail', 2, 9).name("Detail").listen().onFinishChange(function(value) {
					detail = parseInt(detail);
					worldSize = Math.pow(2, detail) + 1;
                    generate();
                });

                gui.add(this, 'roughness', 0.0, 100.0, 1.0).name("Roughness").listen().onFinishChange(function(value) {
                	generate();
                });

				gui.add(button,'GeneratePerlin').name("Generate Perlin");
				gui.add(button,'GenerateDiamondSquare').name("Generate Diamond Square");
				gui.close();

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

			}

			function generate() {
				scene.remove(mesh);
				var heightMultiplier = 1;
				if (perlin)
				{
					heightMultiplier = roughness;
					data = generateHeightFromPerlinNoise( worldSize );
				}
				else if (diamondSquare)
				{
					heightMultiplier = 1;
					data = generateHeightFromDiamondSquare( worldSize );
				}


				var terrain_geometry = new THREE.PlaneGeometry(7500, 7500, worldSize - 1, worldSize - 1);

                var min_height = Infinity;
                var max_height = -Infinity;
                for (var y = 0; y < worldSize - 1; y++) {
                    for (var x = 0; x < worldSize - 1; x++) {
                        var height_val = data[x + (worldSize) * y] * heightMultiplier;
                       	if ( height_val < min_height ) min_height = height_val;
                        if ( height_val > max_height ) max_height = height_val;
                        if ( height_val < 0 ) height_val = 0;
                        if (y === 0 || y === worldSize - 1|| x === 0 || x === worldSize - 1) height_val = 0.0;
                        terrain_geometry.vertices[y + (worldSize) * x].z = height_val;
                    }
                }
				texture = new THREE.CanvasTexture( generateTexture( data, worldSize, worldSize ) );
				texture.wrapS = THREE.ClampToEdgeWrapping;
				texture.wrapT = THREE.ClampToEdgeWrapping;

				terrain_geometry.computeFaceNormals();
                terrain_geometry.computeVertexNormals();
				terrain_material  = new THREE.MeshNormalMaterial();

				mesh = new THREE.Mesh( terrain_geometry, terrain_material );
				//mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );
				mesh.rotation.x = -Math.PI / 2.0;
				scene.add( mesh );
			}

			function generateHeightFromPerlinNoise( worldSize ) {

				var size = worldSize * worldSize, data = new Uint8Array( size  ),
				perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

				for ( var j = 0; j < 4; j ++ ) {

					for ( var i = 0; i < size; i ++ ) {

						var x = i % worldSize, y = ~~ ( i / worldSize );
						data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );
					}

					quality *= 5;

				}

				return data;
			}

			function generateHeightFromDiamondSquare( worldSize ) {

				var size = worldSize;
				var max = size - 1;
				var map = new Float32Array(size * size);

                set(0, 0, max);
                set(max, 0, max / 2);
                set(max, max, 0);
                set(0, max, max / 2); 

                divide(max);

                function set (x, y, val) {
                	map[x + size * y] = val;
            	}

            	function get (x, y) {
                	if (x < 0 || x > max || y < 0 || y > max) return -1;
                	return map[x + size * y];
            	}

                function divide(p_size) {
                    var x, y, half = p_size / 2;
                    var scale = roughness * p_size;
                    if (half < 1) return;

                    for (y = half; y < max; y += p_size) {
                        for (x = half; x < max; x += p_size) {
                            square(x, y, half, Math.random() * scale * 2 - scale);
                        }
                    }
                    for (y = 0; y <= max; y += half) {
                        for (x = (y + half) % p_size; x <= max; x += p_size) {
                            diamond(x, y, half, Math.random() * scale * 2 - scale);
                        }
                    }
                    divide(p_size / 2);
                }

                function average(values) {
                    var valid = values.filter(function (val) {
                        return val !== -1;
                    });
                    var total = valid.reduce(function (sum, val) {
                        return sum + val;
                    }, 0);
                    return total / valid.length;
                }

                function square(x, y, size, offset) {
                    var ave = average([
                        get(x - size, y - size), // upper left
                        get(x + size, y - size), // upper right
                        get(x + size, y + size), // lower right
                        get(x - size, y + size) // lower left
                    ]);
                    set(x, y, ave + offset);
                }

                function diamond(x, y, size, offset) {
                    var ave = average([
                        get(x, y - size), // top
                        get(x + size, y), // right
                        get(x, y + size), // bottom
                        get(x - size, y) // left
                    ]);
                    set(x, y, ave + offset);
                }

                return map;
			}

			function generateTexture( data, width, height ) {

				var canvas, canvasScaled, context, image, imageData,
				level, diff, vector3, sun, shade;

				vector3 = new THREE.Vector3( 0, 0, 0 );

				sun = new THREE.Vector3( 1, 1, 1 );
				sun.normalize();

				canvas = document.createElement( 'canvas' );
				canvas.width = width;
				canvas.height = height;

				context = canvas.getContext( '2d' );
				context.fillStyle = '#000';
				context.fillRect( 0, 0, width, height );

				image = context.getImageData( 0, 0, canvas.width, canvas.height );
				imageData = image.data;

				for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

					vector3.x = data[ j - 2 ] - data[ j + 2 ];
					vector3.y = 2;
					vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
					vector3.normalize();

					shade = vector3.dot( sun );

					imageData[ i ] = ( 113 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007);
					imageData[ i + 1 ] = ( 156 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007);
					imageData[ i + 2 ] = ( 20 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007);
				}

				context.putImageData( image, 0, 0 );

				// Scaled 4x

				canvasScaled = document.createElement( 'canvas' );
				canvasScaled.width = width * 4;
				canvasScaled.height = height * 4;

				context = canvasScaled.getContext( '2d' );
				context.scale( 4, 4 );
				context.drawImage( canvas, 0, 0 );

				image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
				imageData = image.data;

				for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

					var v = ~~ ( Math.random() * 5 );

					imageData[ i ] += v;
					imageData[ i + 1 ] += v;
					imageData[ i + 2 ] += v;

				}

				context.putImageData( image, 0, 0 );

				return canvasScaled;
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				//stats.update();

			}

			function render() {

				controls.update( clock.getDelta() );
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
